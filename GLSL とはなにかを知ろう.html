<!DOCTYPE html>
<html class="gr__school_souhonzan_org"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link rel="stylesheet" href="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/style.css" type="text/css">
    <link rel="stylesheet" href="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/hljs.css" type="text/css">
    <script type="text/javascript" src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/script.js"></script>
    <script type="text/javascript" src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/highlight.js"></script>
    <script type="text/javascript">hljs.initHighlightingOnLoad();</script>
    <title>GLSL とはなにかを知ろう</title>
    <script>window.contentList = '[{"content":"自己紹介","count":0},{"content":"本スクールの開催概要","count":2},{"content":"講義を始める前に","count":7},{"content":"さあはじめよう！","count":12},{"content":"進化するシェーダ","count":14},{"content":"ここまでの要点","count":21},{"content":"3D API とシェーダ","count":23},{"content":"OpenGL と OpenGL ES","count":27},{"content":"OpenGL ES と WebGL","count":29},{"content":"GLSL","count":30},{"content":"ここまでの要点","count":34},{"content":"固定機能パイプラインとプログラマブルシェーダ","count":36},{"content":"すべて自分でやらなくてはならないプログラマブルシェーダ","count":42},{"content":"シェーダの種類","count":45},{"content":"頂点シェーダ","count":47},{"content":"フラグメントシェーダ","count":50},{"content":"WebGL で利用できるシェーダ","count":53},{"content":"その他のシェーダ","count":55},{"content":"ここまでの要点","count":58},{"content":"グラフィックスパイプライン","count":60},{"content":"ここまでの要点","count":70},{"content":"サンプルを見ながら考えていこう","count":72},{"content":"サンプル 001","count":74},{"content":"WebGL の初期化の流れ","count":75},{"content":"WebGL の初期化の流れまとめ","count":90},{"content":"WebGL の描画までの流れ","count":92},{"content":"WebGL の描画までの流れのまとめ","count":97},{"content":"GLSL の変数","count":99},{"content":"GLSL の変数につくストレージ修飾子","count":103},{"content":"GLSL のストレージ修飾子まとめ","count":107},{"content":"ロケーション取得方法の基本","count":108},{"content":"ロケーション取得から描画まで","count":111},{"content":"サンプル 001（再）","count":112},{"content":"サンプル 002","count":119},{"content":"サンプル 003","count":120},{"content":"サンプル 004","count":121},{"content":"サンプル 005","count":122},{"content":"サンプル 006","count":123},{"content":"サンプル 007","count":124},{"content":"サンプル 008","count":125},{"content":"サンプル 009","count":126},{"content":"サンプル 010","count":127},{"content":"サンプル 011","count":128},{"content":"次回へ向けて","count":130},{"content":"おまけ","count":133},{"content":"question 1","count":134},{"content":"question 2","count":135},{"content":"question 3","count":136},{"content":"question 4","count":137},{"content":"question 5","count":138},{"content":"question 6","count":139},{"content":"question 7","count":140},{"content":"question 8","count":141},{"content":"question 9","count":142},{"content":"question 10","count":143},{"content":"結果はいかに！？","count":144}]';</script>
</head>
<body data-gr-c-s-loaded="true" cz-shortcut-listen="true">
    <div id="wrap">
        <div id="bar">
            <div id="progress" style="width: 0%;"></div>
        </div>
        <div id="header">
            <div id="rect">
                <div id="icon">
                    <!-- <div></div><div></div><div></div> -->
                </div>
            </div>
            <h1>GLSL とはなにかを知ろう</h1>
            <div id="author">doxas</div>
        </div>
        <div id="content">
            <div class="active">
                <div id="home">
                    <h2>GLSL とはなにかを知ろう</h2>
                    <h3>シェーダと GLSL の概念・基礎知識</h3>
                </div>
            </div>

<div class="page">
	<h4>自己紹介</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/doxas.png"></p>
	<p>杉本 雅広（すぎもと まさひろ）</p>
	<p><a target="_blank" href="https://twitter.com/h_doxas">@h_doxas Twitter</a></p>
</div>
<div class="page">
	<h4>自己紹介</h4>
	<p><a target="_blank" href="http://wgld.org/">WebGL 開発支援サイト wgld.org</a></p>
	<p><a target="_blank" href="http://webgl.souhonzan.org/">WebGL 総本山</a></p>
	<p>WebGL に関する開発支援を目的とした入門サイトや、WebGL を利用した事例などを紹介するサイトを運営しています。</p>
	<p>イベントへの登壇や書籍執筆など、WebGL 普及のための活動を行っています。</p>
</div>
<div class="page">
	<h4>本スクールの開催概要</h4>
	<p>本スクールは、WebGL などの OpenGL ファミリで主に利用されている <strong>GLSL</strong> と呼ばれるシェーダ言語を主題に、<em>シェーダの記述に特化した</em> 技術を広く学習することを目的としたスクールになります。</p>
	<p>シェーダとはそもそもなんなのか、そして WebGL や GLSL との関係とはどんなものなのか。さらには、シェーダを記述できることの利点や、もちろんシェーダ記述のスキルアップのための基礎から応用までの知識を、総合的に扱っていきます。</p>
</div>
<div class="page">
	<h4>本スクールの開催概要</h4>
	<p>シェーダは大変奥が深く、同時に非常に難しいジャンルでもあります。短い講義時間のなかだけで一度に全てを理解するのは、なかなか大変です。</p>
	<p>本スクールでは、Slack を導入するなど講師への質問が行いやすい環境をできる限り作るようにしています。ぜひ、本講義や、プラスワン講義など、講義の時間のなかだけでなくそのほかの場面でも、気軽に質問など投げかけていただければと思います。</p>
	<p><span class="capt">質問の回数も、また期限も設けませんので質問しないのは損です！</span></p>
</div>
<div class="page">
	<h4>本スクールの開催概要</h4>
	<p>また、本スクールの本講義（私の担当する講義）が全て修了したあと、来年の 1 月に行う第五回は <em>受講者全員による発表会</em> を行う予定です。</p>
	<p>昨年も最後に発表会を行ったのですが、そこでは私が想像した以上に様々な作品が受講者さんたちから出されました。また他のひとの作品を見ることによって、それが刺激やモチベーションにつながったという受講者も多かったようです。</p>
	<p>基本的には、このような取り組みが確実にみなさんの糧になると私は信じていますし、今年も発表会を行うことにしました。</p>
	<p><span class="capt">発表する機会ってありそうで意外と無いですよね</span></p>
</div>
<div class="page">
	<h4>本スクールの開催概要</h4>
	<p>明確なアウトプットの場というゴールがあることによって、より自分自身の表現を具体化できるということは誰しもあると思います。</p>
	<p>ぜひ、自分がどんなものを作れるようになりたいのか、どんな表現をしてみたいのか、少しずつでも構いませんのでスクールを通じてイメージできるように意識しながら受講してみてください。</p>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>講義を始める前に</h4>
	<p>今回のスクールは、GLSL に特化した短期スクールとなります。プラットフォームには、最も気軽に GLSL と向き合える WebGL を使っていきます。</p>
	<p>文字通り、シェーダや GLSL についてがメインテーマになりますので、WebGL や JavaScript 
に関して少々説明を省いて進めていく形になります。もし、通常の JavaScript の記述方法や、WebGL 
実装部分での疑問点で詰まってしまいそうな場合は、遠慮無く、質問していただいて大丈夫です。</p>
	<p><span class="capt">特に普段 JS 書かない方はマジで遠慮せずに聞いてください</span></p>
</div>
<div class="page">
	<h4>講義を始める前に</h4>
	<p>また、今回は WebGL の基礎スクールではないので、始めからある程度 WebGL 実装の整えられた環境を用意してあります。</p>
	<p>同時に、GLSL やシェーダというよりも WebGL の API 特有な処理となるような部分については、本講義内では触れない場合もあることをまずはご理解ください。</p>
	<p><span class="capt">全部やってたら時間足りないからね！</span></p>
</div>
<div class="page">
	<h4>講義を始める前に</h4>
	<p>さらに、オンラインでアクセスすることができる、ブラウザから操作可能な GLSL のエディタも世の中には結構あります。</p>
	<p>プラスワン講義の場など、場面によってはこちらを利用してシェーダを書くこともあります。</p>
	<p><a target="_blank" href="https://doxas.org/work/glsl_editor/">オンライン GLSL エディタ</a></p>
	<p><span class="capt">こちらはよりシェーダだけで描く！ という色合いが強いです。</span></p>
</div>
<div class="page">
	<h4>講義を始める前に</h4>
	<p>これらのエディタでは、GLSL を記述することにしっかり集中できるよう工夫してあります。使い方はまたいずれ説明しますので、ひとまずいつでもページを開けるようにしておいてください。</p>
	<p>また、事前に参加者のみなさんには招待を送っていますが、今回のスクールでは、Slack をコミュニケーションのためのツールとして利用していきます。</p>
</div>
<div class="page">
	<h4>講義を始める前に</h4>
	<p>講師と受講者、あるいは受講者同士などで、気軽にコミュニケーションを取ってもらいたいというのが Slack を導入した意図です。</p>
	<p>どうしても、口頭で質問するというのは心理的障壁が大きいと思うのですが、Slack であれば、ログも一定量は残りますし、質問者以外の方もその内容を把握できますし、メリットが多いのかなと思っています。</p>
	<p><span class="capt">他の人にとっても有用になるかもしれないので、臆せずどんどん質問しよう！</span></p>
</div>
<div class="page">
	<h4>さあはじめよう！</h4>
	<p>さて、前置きが若干長くなりましたが、早速講義を始めていきます。</p>
	<p>まずは、シェーダを記述するために最低限必要となる、前提や基礎を固めておきましょう。</p>
	<p>後半は実際にみなさんにも手を動かしてコードを記述してもらうフェーズが待っています。まずは基本的な概念の部分からしっかり押さえていきましょう。</p>
	<p><span class="capt">必ずしも暗記する必要はないので楽な気持ちで聞いてください</span></p>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>進化するシェーダ</h4>
	<p>シェーダ、という言葉には非常に広い意味があり、一言で表現するのは難しいです。</p>
	<p>ただ、一般に解釈されているシェーダをあえて端的に表現すると「<em>GPU を利用し高速にグラフィックスを描画するための技術や概念の総称</em>」というふうに言えるかもしれません。</p>
</div>
<div class="page">
	<h4>進化するシェーダ</h4>
	<p>WebGL の登場で、ウェブの世界でも、シェーダの存在は日々大きくなっていっています。</p>
	<p>これまでのウェブでは、速度の関係からどうしても難しかったような表現が、WebGL の高速な動作によって実現可能になったのですね。</p>
	<p>WebGL というと一見 3DCG 専用のように感じるかもしれませんが、これは必ずしも 3D とは限りません。2D の描画であっても、GLSL の高速な動作が役に立つ場面は多いと言えます。</p>
</div>
<div class="page">
	<h4>進化するシェーダ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/001.jpg" alt=""></p>
	<p><a target="_blank" href="https://art4globalgoals.com/en">#Art4GlobalGoals – 17 Issues Interpreted by Leon Löwentraut in His Art</a></p>
	<p><span class="capt">二次元表現も要はシェーダの使い方次第</span></p>
</div>
<div class="page">
	<h4>進化するシェーダ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/002.jpg" alt=""></p>
	<p><a target="_blank" href="https://madclem.github.io/">MADCLEM - Experimental Porfolio 2018</a></p>
	<p><span class="capt">一見平面的に見えても立体的に展開されていることも</span></p>
</div>
<div class="page">
	<h4>進化するシェーダ</h4>
	<p>現在では、シェーダは映像表現のためだけに限らず、あらゆる演算処理を担う縁の下の力持ちになりました。</p>
	<p>たとえば、流体表現のための、流れや勢いを計算するために使われたり、フラクタルを描画するための計算に使われたり、多くの演算が必要となる様々
なシーンでシェーダが活躍しています。昨年、Google 
がディープラーニングをブラウザ上で行うためのライブラリを発表したりもしましたが、これも裏では WebGL に関係した技術を使っています。</p>
	<p>とは言えやはり、これらの計算の結果も大抵の場合は、最終的にグラフィックスを生成するために使われます。つまり、シェーダの最大の仕事はやはり <em>グラフィックスを描くことに繋がる</em> 場合がほとんどと考えていいでしょう。</p>
</div>
<div class="page">
	<h4>進化するシェーダ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/003.jpg" alt=""></p>
	<p><a target="_blank" href="https://github.com/tensorflow/tfjs">tensorflow/tfjs</a></p>
	<p><span class="capt">やや変則的な活用例ですが機械学習も JavaScript で扱える時代に</span></p>
</div>
<div class="page">
	<h4>進化するシェーダ</h4>
	<p>シェーダはその役割に応じて、様々な名称がつけられています。</p>
	<p>API が変わると微妙に呼び方が変わったりもするので紛らわしいですが、共通する点としては GPU を利用した高速な演算処理が行える場合が多いです。</p>
</div>
<div class="page">
	<h4>ここまでの要点</h4>
	<ul>
		<li>シェーダは高い演算能力を誇る GPU を駆使することで高速に計算を行う</li>
		<li>高速だからこそ、3D のような計算負荷の高い処理を行うことも可能になる</li>
		<li>高速な動作でグラフィックス生成のあらゆる行程で活躍する</li>
		<li>近年では機械学習などグラフィックス以外の分野でもシェーダが使われる場合がある</li>
		<li>役割に応じて○○シェーダ、というふうに名前が付けられている場合が多い</li>
	</ul>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>3D API とシェーダ</h4>
	<p>3DCG を描くためには、多くの計算や行程が必要になります。そして大抵の場合、それらは非常に負荷の大きなものになるため GPU と呼ばれる高速な演算装置を利用することが多いです。</p>
	<p>PC であれモバイル端末であれ、近年のデジタルデバイスの多くにはこの GPU がなんらかの形で備わっています。CPU 
とメモリを共有しているタイプの安価なものから、GPU 
としての性能に特化したグラフィックボード（あるいはビデオカードとも）と呼ばれる専用パーツまで、様々な種類のものがあります。</p>
	<p><span class="capt">高性能な GPU を積んでいれば当然グラフィックス関連処理が高速に</span></p>
</div>
<div class="page">
	<h4>3D API とシェーダ</h4>
	<p>そんな GPU を利用するためのインターフェース（API）には、OS の種類や、その用途に合わせていくつかの種類があります。</p>
	<p>Windows であれば、DirectX と呼ばれる Windows に最適化された高性能な API 
が存在しますし、オープンソースで提供されている著名な API として OpenGL 
などがありますね。これらは非常に低レベルの、よりハードウェア（GPU）に近い部分でアプリケーションとハードウェアとの間を取り持ってくれます。</p>
	<p>ソフトウェアを設計する我々エンジニアは、DirectX や OpenGL の使い方を覚えることによって、これらの API を通して間接的に GPU の性能を引き出した高いパフォーマンスを誇るアプリケーションを制作することができるわけです。</p>
</div>
<div class="page">
	<h4>3D API とシェーダ</h4>
	<p>ちなみに、近年その名前をよく耳にするようになった Vulkan や Metal は、OpenGL よりもさらにハードウェアに近い低レベルなレイヤーを操作するための API です。</p>
	<p>ハードウェアに近い部分を直接操作することができるため総じて高速ですが、難易度もかなり高くなります。GPU のハードウェアアーキテクチャなどを正しく理解していないと、使いこなすことはかなり難しいと考えていいでしょう。</p>
	<p><span class="capt">すごい雑な言い方ですが、もはや OpenGL そのものを自作するような感じです</span></p>
</div>
<div class="page">
	<h4>3D API とシェーダ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/004.jpg" alt=""></p>
	<p><span class="capt">CPU と GPU の間を取り持ってくれる API のイメージ</span></p>
</div>
<div class="page">
	<h4>OpenGL と OpenGL ES</h4>
	<p>OpenGL はその名の通り、オープンな規格として Khronos によって管理されている 3D API で、モバイル向けの OpenGL ES と共に、様々なところで利用されています。</p>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/005.jpg" alt=""></p>
	<p><span class="capt">ES のほうはモバイル向けの軽量な OpenGL 実装です</span></p>
</div>
<div class="page">
	<h4>OpenGL と OpenGL ES</h4>
	<p>スマートフォンにおけるグラフィックス API は事実上 OpenGL ES 一択という状況が長らく続いていました。</p>
	<p>しかし最近はその流れがちょっと変わってきましたね。Apple は独自の API である Metal を推奨していますが、かといって Metal が利用できるのは Apple の製品のみになるので、このあたりは開発者としても判断が難しいところです。</p>
	<p>もしマルチプラットフォームに対応するとなれば、Metal に対応する環境と、そうでない環境用の OpenGL 実装とを、両方作らなくてはならないということになります。</p>
</div>
<div class="page">
	<h4>OpenGL ES と WebGL</h4>
	<p>ウェブというプラットフォームで利用される WebGL も、やはり世界標準の仕様に即した API です。ただしこれはあくまでも JavaScript の API ですね。</p>
	<p>内部的には、OpenGL ES の 2.0 のグラフィックス API を踏襲した実装になっています。</p>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/006.jpg" alt=""></p>
</div>
<div class="page">
	<h4>GLSL</h4>
	<p>さて、それではこのスクールの主役である GLSL とはなんなのでしょうか。</p>
	<p>GLSL（Open<em>GL</em> <em>S</em>hading <em>L</em>anguage）は、OpenGL ファミリーで利用できるシェーダを記述するため言語のことをいいます。</p>
	<p>OpenGL という 3D API がまずあり、その API でシェーダを利用する際に、シェーダを記述するための言語として GLSL を使う、ということです。</p>
</div>
<div class="page">
	<h4>GLSL</h4>
	<p>OpenGL のファミリーである WebGL でも、やはりシェーダの記述には GLSL を利用します。</p>
	<p>現状の WebGL で利用する GLSL のバージョンは、GLSL ES 1.0 です。これは <em>OpenGL ES 2.0 相当で利用されているものと同じ</em>ですね。</p>
	<p><span class="capt">WebGL 1.0 には、GLSL ES 1.0 を使う！</span></p>
</div>
<div class="page">
	<h4>GLSL</h4>
	<p>さて、少し紛らわしい感じになってきました。ちょっと整理しましょう。</p>
	<p><em>OpenGL</em> は、GPU を利用するための 3D API でしたね。そして、その OpenGL のファミリーのなかで、モバイル端末向けに軽量化されたものが <em>OpenGL ES</em> です。さらに、<em>WebGL</em> はこの OpenGL ES をブラウザから制御できるようにしたものであり、中身はほとんど OpenGL ES と同じです。</p>
	<p>これらの OpenGL ファミリーでは、シェーダを記述するための専用の言語を用い、それが <em>GLSL</em> と呼ばれているのでした。そしてこの GLSL にも様々なバージョンが存在する、ということになります。</p>
</div>
<div class="page">
	<h4>GLSL</h4>
	<p>ちなみに GLSL は、Unity などでも利用することができますが、Unity には専用のシェーダを記述するためのプラットフォームがあり、GLSL が必ずしも推奨されているわけではありません。</p>
	<p>しかし、シェーダの概念そのものは似通った部分がいくつもありますので、GLSL 
の記述を通して、シェーダそのものに対するスキルを磨いていくことはけして無駄にはならないはずです。最初のうちはあまり難しく考えず、3DCG 
やシェーダそのものにどんどん慣れていきましょう。</p>
	<p>WebGL の素晴らしいところはブラウザさえあれば実行できることです。だからこそ、学習には非常に適した環境だと言えますしどんどん臆せずトライしていくことが大切です。</p>
</div>
<div class="page">
	<h4>ここまでの要点</h4>
	<ul>
		<li>GPU を直接触るのは難しいので、インタフェースとして 3D API を使う</li>
		<li>3D API にはプラットフォームなどに応じていくつかの種類がある</li>
		<li>DirectX や OpenGL、OpenGL ES、Metal、Vulkan など様々</li>
		<li>OpenGL でシェーダを記述するための専用の言語が GLSL</li>
		<li>シェーダ記述言語もプラットフォームによって様々である</li>
	</ul>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>固定機能パイプラインとプログラマブルシェーダ</h4>
	<p>そもそも、OpenGL という API が存在するにもかかわらず、それ以外にわざわざ GLSL のような専用のシェーダ記述言語が必要なのでしょうか。</p>
	<p>コンピュータグラフィックスの歴史を振り返るとその必要性が見えてきます。</p>
	<p><span class="capt">あともう少しだけ、歴史の話をします</span></p>
</div>
<div class="page">
	<h4>固定機能パイプラインとプログラマブルシェーダ</h4>
	<p>かつて、OpenGL には、現在シェーダが担っている領域の機能が <em>全て備わって</em> いました。</p>
	<p>ちょっと驚くかもしれませんが、昔は OpenGL には GLSL のようなシェーダ記述に特化した機構は備わっておらず、全て OpenGL 単体で完結するように作られていたんですね。</p>
	<p><span class="capt">そもそもシェーダを書く、という概念が昔は無かった！</span></p>
</div>
<div class="page">
	<h4>固定機能パイプラインとプログラマブルシェーダ</h4>
	<p>この、OpenGL 内に組み込まれていた現在のシェーダに相当する機能を、現在では固定機能パイプラインと呼んでいます。</p>
	<p>その呼び方からもわかるとおり、これは機能が完全に固定されているもので汎用性に乏しく、ある程度同じようなことしかできないものでした。</p>
</div>
<div class="page">
	<h4>固定機能パイプラインとプログラマブルシェーダ</h4>
	<p>コンピュータグラフィックスが日々進化していく過程で、固定機能パイプラインのような限定的な機能だけでは、求める結果が得られないようになってきます。そこで生まれたのが GLSL のような、シェーダ機能を自由にプログラマが制御できる機構です。</p>
	<p>それまではシェーディングに関することは全て OpenGL（正確には GPU 
などのハードウェア）が一括して行っており、その領域にプログラマが介入する余地はありませんでした。しかし GLSL 
のようなシェーダを自由に記述することができる仕組みが誕生したことで、より汎用性の高い、様々な演算や表現を行うことが可能になりました。</p>
</div>
<div class="page">
	<h4>固定機能パイプラインとプログラマブルシェーダ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/007.jpg" alt=""></p>
	<p><span class="capt">複雑なライティングやブルーム（光の溢れ）などはプログラマブルシェーダだからこそできる</span></p>
</div>
<div class="page">
	<h4>固定機能パイプラインとプログラマブルシェーダ</h4>
	<p>このように、プログラマの裁量によって自由にシェーディングを制御できるような機構を、プログラマブルシェーダ、というふうに呼びます。</p>
	<p>そして、WebGL や OpenGL ES はこのプログラマブルシェーダを用いることが基本です。というより、両者には <em>固定機能パイプラインは存在しません</em> ので、必然的にシェーダを自前で実装してやる必要があります。</p>
	<p>シェーダを自力で実装する必要があるため、若干難易度が高くはなりますが、その分、豊富な表現や制御が可能になっています。</p>
</div>
<div class="page">
	<h4>すべて自分でやらなくてはならないプログラマブルシェーダ</h4>
	<p>ここまで来ると、やっと本スクールの本題に入ってきます。</p>
	<p>つまり本スクールでは、<em>プログラマブルシェーダの記述方法を学習</em> していきます。環境によっては固定機能パイプラインが肩代わりしてくれるような基本的なことでさえも、WebGL と GLSL を用いる場合は <em>全て自分で実装しなければなりません</em>。</p>
	<p>最初は、これがとても難しいことのように感じられるかもしれませんが、見方を変えてみれば基本の部分からしっかり取り組むことができるということでもありますね。</p>
	<p><span class="capt">逆に Unity とかは勝手に全部やってくれちゃいます</span></p>
</div>
<div class="page">
	<h4>すべて自分でやらなくてはならないプログラマブルシェーダ</h4>
	<p>3D 数学やシェーダの記述は、本当に難しいです。また、奥深すぎてゴールがありません。</p>
	<p>しかしその分、ひとつひとつ確実にスキルアップしていくことで、確実にみなさんのなかに価値ある技術が積み上げられていくはずです。</p>
	<p>全力でサポートしますので、一緒にがんばっていきましょう。</p>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>シェーダの種類</h4>
	<p>さて、ここからはより深くシェーダについて見ていきます。</p>
	<p>まずは、現在一般によく利用されているシェーダの種類にどんなものがあるのか、見ていきましょう。</p>
</div>
<div class="page">
	<h4>シェーダの種類</h4>
	<p>とは言え、ここではみなさんがこれから学習していく予定の、当スクールで登場するシェーダに、ある程度限った話をします。</p>
	<p>先程も少し書きましたが、現在ではシェーダの種類や役割は非常に多岐に渡るのでそれら全てを一度に理解するのは難しいです。</p>
	<p>逸る気持ちもあるかもしれませんが、まずはどんなプラットフォーム上でも利用できる基本的なシェーダから徐々に覚えていきましょう。</p>
</div>
<div class="page">
	<h4>頂点シェーダ</h4>
	<p>まず最初に登場するのが <em>頂点シェーダ</em> です。</p>
	<p>このシェーダは、3DCG に欠かすことのできない、頂点の座標変換を主な役割とするシェーダです。</p>
	<p>3D プログラミングでは、あらゆるものは頂点によって表現されます。頂点シェーダを利用することで、この頂点の位置や、頂点の持つ様々な情報を自在に制御することが可能になります。</p>
</div>
<div class="page">
	<h4>頂点シェーダ</h4>
	<p>頂点は、3DCG を描画する上で欠かせない、と書きました。ここはあえて詳細を省きますが、頂点がひとつで点を、頂点がふたつで線を、それ以上の個数の頂点を使うことで三角形や四角形を表現するのが、3DCG の一般的な概念です。</p>
	<p>頂点シェーダは、この頂点ひとつひとつを制御するためのものです。ですから、<em>頂点の個数＝頂点シェーダが実行される回数</em> となるのが普通です。</p>
	<p><span class="capt">描画する頂点が少なければ頂点シェーダの負荷も少なくなる</span></p>
</div>
<div class="page">
	<h4>頂点シェーダ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/008.jpg" alt=""></p>
	<p><span class="capt">頂点が増えれば増えるほど頂点シェーダの実行回数が増える</span></p>
</div>
<div class="page">
	<h4>フラグメントシェーダ</h4>
	<p>一方、代表的なシェーダとして頂点シェーダと並ぶ存在なのが <em>フラグメントシェーダ</em> です。API の種類によっては、ピクセルシェーダなどと呼ばれることもあります。</p>
	<p>このシェーダは頂点シェーダとは役割が異なり、最終的にスクリーンに描かれる <em>ピクセルひとつひとつ</em> を対象とした処理を行います。</p>
</div>
<div class="page">
	<h4>フラグメントシェーダ</h4>
	<p>つまり、画面の解像度が大きい場合、当然フラグメントシェーダによる負荷は大きなものになります。</p>
	<p>頂点シェーダは頂点の個数に比例して負荷が増えますが、フラグメントシェーダは実行されるピクセル数が増減することで大きな影響を受けます。</p>
</div>
<div class="page">
	<h4>フラグメントシェーダ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/009.jpg" alt=""></p>
	<p><span class="capt">描画する領域の広さによって塗るべきピクセルの数は大きく変化する</span></p>
</div>
<div class="page">
	<h4>WebGL で利用できるシェーダ</h4>
	<ul>
		<li>頂点シェーダ</li>

	</ul>	<p>    - 頂点の個数分だけ頂点ごとに実行される</p>
	<ul>
		<li>フラグメントシェーダ</li>

	</ul>	<p>    - 描画するピクセル単位で実行される</p>
	<p><span class="capt">この違いをしっかり意識できることが非常に重要です</span></p>
</div>
<div class="page">
	<h4>WebGL で利用できるシェーダ</h4>
	<p>ここまで紹介してきた頂点シェーダとフラグメントシェーダの両者は、WebGL でも利用できる二種類のシェーダです。</p>
	<p>WebGL と GLSL を使ったアプリケーションでは、このふたつを使いこなすことであらゆる表現を行っていきます。</p>
	<p>しかし、その他のプラットフォーム上では、頂点シェーダとフラグメントシェーダ以外のシェーダが備わっているケースもあります。</p>
</div>
<div class="page">
	<h4>その他のシェーダ</h4>
	<p>代表的なところでは、ジオメトリシェーダがあります。</p>
	<p>ジオメトリシェーダは、OpenGL ES 3.2 や、DirectX、OpenGL 
などで利用できるシェーダです。このシェーダは頂点シェーダとフラグメントシェーダの間に割り込むようなタイミングで動作するもので、頂点シェーダから送
られてきた頂点の情報を、さらに加工してからフラグメントシェーダへと渡します。</p>
	<p><span class="capt">WebGL にはジオメトリシェーダは残念ながらありません</span></p>
</div>
<div class="page">
	<h4>その他のシェーダ</h4>
	<p>ジオメトリシェーダの他にも、プラットフォームを限定したシェーダはいくつもあります。</p>
	<p>たとえば OpenGL には、テッセレーションシェーダやコンピュートシェーダなどのさらなるシェーダが存在します。ほかにも Unity にはサーフェイスシェーダと呼ばれる独自のシェーダが備わっています。</p>
	<p>このように、シェーダには様々な役割や実装があり、プラットフォームに応じて独自の仕様を持っている場合が多く、得てして非常に難解な場合が多いです。</p>
</div>
<div class="page">
	<h4>その他のシェーダ</h4>
	<p>シェーダにはたくさんの種類がありますが、その中でも頂点シェーダとフラグメントシェーダ（ピクセルシェーダ）は非常に重要なシェーダだと言えます。</p>
	<p>最も基本的な構成のシェーダであり、おおよそどのようなプラットフォームにおいてもこれらに相当するシェーダが備わっているのが普通です。両者をしっかりと理解しておけば、それ以外のシェーダについても理解が深まるでしょう。</p>
</div>
<div class="page">
	<h4>ここまでの要点</h4>
	<ul>
		<li>シェーダにはたくさんの種類がある</li>
		<li>プラットフォームを限定するものもあり非常に難解な場合が多い</li>
		<li>頂点シェーダとフラグメントシェーダは特に大切なシェーダ</li>
		<li>頂点シェーダは頂点の個数に応じて呼び出される</li>
		<li>フラグメントシェーダはピクセルの個数に応じて呼び出される</li>
		<li>WebGL と GLSL の組み合わせの場合は、この二種類のシェーダを記述可能</li>
	</ul>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p>さて、GLSL で記述したシェーダには（ここではひとまず）頂点シェーダとフラグメントシェーダの二種類があることがわかりましたが、これらはディスプレイに映像が映し出されるまでの過程でどのように利用されるのでしょうか。</p>
	<p>ここでは簡単に、概念図を用いてその概要だけ把握しておきましょう。</p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/010.jpg" alt=""></p>
	<p><span class="capt">これはほんの一部だけを抜粋したものです</span></p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p>アプリケーションから情報を受け取った頂点シェーダは、頂点を指定された情報を元に座標変換しパイプラインの次のステージに送ります。</p>
	<p>そして座標変換された頂点は、ラスタライズなどの処理を経てフラグメントシェーダへと渡されます。フラグメントシェーダで着色などが行われたあと、いくつかの行程をさらに経た後にやっとディスプレイに映像が出力されます。</p>
	<p>このパイプラインの行程全体をグラフィックスパイプラインと呼び、非常に多くの行程があります。</p>
	<p><span class="capt">レンダリングパイプライン、と呼ぶ場合もあります。</span></p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p>かつては、グラフィックスパイプラインには固定機能シェーダが埋め込まれた状態になっており、完全に固定されていました。</p>
	<p>つまり、頂点情報などをパイプラインに流し込むと、あとは勝手に GPU の内部でハードウェア（GPU）によってレンダリングまでが一気に実行されていたわけです。</p>
	<p>これは非常に手間が少なく簡単で便利なのですが、その分、レンダリング結果はどうしてもシンプルになりますし、誰がどのようにレンダリングしても同じようなレンダリング結果にしかならないものでした。</p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p>このグラフィックスパイプラインのいくつかの行程を、プログラマが自由に実装・改良できるようにしたものこそが、他ならぬプログラマブルシェーダです。</p>
	<p>頂点シェーダ、フラグメントシェーダはもちろんのこと、それら以外のシェーダについても基本的にはこのグラフィックスパイプラインの何かしらの処理を置き換えたり、拡張したりするものであるのが普通です。</p>
	<p><span class="capt">様々なシェーダの登場により、グラフィックスパイプラインが民主化された！</span></p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p>さてさて、グラフィックスパイプラインに独自に改良を加えることができるプログラマブルシェーダですが……</p>
	<p>独自の実装ができると言っても、レンダリングのフロー（処理順序）そのものは、ある程度決まっています。</p>
	<p>まず A という作業を行わないと B という作業は行えない、といったように処理フロー上の優先順位というのがあるのですね。</p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p>ここで最も重要なポイントとなるのは、頂点シェーダとフラグメントシェーダのうち、<em>先に呼び出されるのは常に頂点シェーダ</em> であるということ。</p>
	<p>これはどうしてかと言うと、頂点シェーダによって頂点が動いたり変形したりするなかで、当然画面に映るものと映らないものが出てきますよね。</p>
	<p>頂点シェーダがまず最初に形を作り、そのあとの行程で「色を塗るべきだと判断されたピクセルに対してのみ」フラグメントシェーダが実行されるようになっているわけです。ですからこの処理順序を逆転させることはできないのですね。</p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p>もし仮に、頂点シェーダで処理した結果、ひとつも頂点が画面上に描かれなかったとしたら……</p>
	<p>そのときは、塗るべきピクセルがひとつもないということになりますので、<em>フラグメントシェーダは一度も実行されません</em>。</p>
	<p><span class="capt">これは実は地味に重要です！</span></p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/011.jpg" alt=""></p>
	<p><span class="capt">必ず先に頂点シェーダ（左側の変換処理など）が先に実行される</span></p>
</div>
<div class="page">
	<h4>グラフィックスパイプライン</h4>
	<p>逆に言えば、画面上の全てのピクセルを頂点やポリゴンが覆っている場合、全てのピクセル上で何かしらのフラグメントシェーダが実行されるわけです。</p>
	<p>フル HD の 1920 x 1080 だと、約 214 万ピクセルです。気軽に掛け算をひとつシェーダに追記すると、214 万回の乗算処理が GPU によって処理されることになります。</p>
	<p><span class="capt">そう考えると GPU って半端ない処理能力……</span></p>
</div>
<div class="page">
	<h4>ここまでの要点</h4>
	<ul>
		<li>CG がレンダリングされる過程には順序がある</li>
		<li>その処理の流れを一般にグラフィックスパイプラインと呼ぶ</li>
		<li>つまり、シェーダが実行される順序もやっぱり決まっている</li>
		<li>頂点シェーダが必ず先に実行され、描画すべきかどうかがまず確定し……</li>
		<li>塗るべきピクセルの色を決めるためにフラグメントシェーダが実行される</li>
	</ul>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>サンプルを見ながら考えていこう</h4>
	<p>それでは、GLSL を実際にどのように記述していけばいいのか、少しずつコードのほうも見ていきましょう。</p>
	<p>まず最初は、サンプル 001 からです。</p>
	<p>こちらのサンプルは、主に WebGL 側の処理の流れを把握するためのもので、普段 JavaScript を書いてらっしゃらない方にはちょっと難しいかもしれません。</p>
</div>
<div class="page">
	<h4>サンプルを見ながら考えていこう</h4>
	<p>とは言え、C++ などで同様の実装を OpenGL で組む場合でも、基本的な流れはこれとほとんど同じになります。</p>
	<p>Unity 等の場合は、こういった基盤処理は全て Unity 側で担保してくれるので意識することは無い場合がほとんどでしょう。しかし、こういったアプリケーションの下地の部分を知っておくことはけして無駄にはならないので、コメントを参考にしながら、特にその <em>一連の処理の流れ</em> を把握するようにしましょう。</p>
	<p>参考までに、かなり大雑把ですがサンプル 001 でなにが行われているのか箇条書きにしてみると……</p>
</div>
<div class="page">
	<h4>サンプル 001</h4>
	<p><span class="capt">以下は暗記したりする必要はないです！</span></p>
	<ul>
		<li>ウェブページの読み込み完了と同時に処理を実行開始</li>
		<li>まずは WebGL のコンテキストを取得</li>
		<li>コンテキスト経由で様々な WebGL（OpenGL ES）の命令を実行していく</li>
		<li>シェーダは一種のプログラムなのでそのソースコードを読み込んで利用する</li>
		<li>シェーダをコンパイルしてリンクし、プログラムオブジェクトを生成</li>
		<li>プログラムオブジェクトが JavaScript と GLSL の架け橋になる</li>
		<li>頂点は単なる配列によって定義される</li>
		<li>GLSL 側の変数には <em>ロケーション</em> を通じてアクセスする</li>
		<li>ロケーションを頼りに GPU へデータを転送</li>
		<li>描画命令を発行し、転送済みデータを元に描画が行われる</li>
	</ul>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>箇条書きにするとどうにも「やることが多すぎ」て、なにがなんだかわかりにくいですね……</p>
	<p>でもこれは、どんな 3D API を用いる場合でも <em>残念ながら同じ</em> です。</p>
	<p>最初は途方に暮れてしまいそうになりますが、大事なのは「そのとき理解できなくても気にしすぎない」こと。じっくりと、少しずつ自分に理解できそうなところから慣れ親しんでいけば大丈夫。きっといずれは、全体の流れが理解できるようになってきます。</p>
	<p><span class="capt">まじで最初は特に、理解できないことをネガティブに捉えないことが大事です</span></p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>ということでここから一連の処理の流れをもう少し詳細に説明するのですが……</p>
	<p>まず最初に一番大事なこととして、サンプル 001 を通じて <em>なにを知ってほしいのか</em> を明確にします。</p>
	<p>いまから説明することは全て、<strong>GPU で動作する GLSL</strong> と <strong>アプリケーション本体のある CPU</strong> が連携するために必要な手順です。このことをまずしっかり意識してください。</p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>CPU と GPU は別々のハードウェアなので、相互にやりとりを行うためにはきちんとした手続きが必要です。</p>
	<p>わかりやすく言うなら、PC とプリンタを接続したら、ドライバのインストールとかセットアップをしますよね？ あれと同じです。</p>
	<p><span class="capt">たとえば Word を使って印刷するときを思い浮かべてみると……</span></p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>Word というソフトウェアは、ユーザーが実際に触っているアプリケーション本体だと言えますよね。そしてそのアプリケーションから印刷指示を出したときに最初にそれを受け取るのはプリンターのドライバ（つまりプリンターにアクセスするためのインタフェース）です。</p>
	<p>ドライバというインタフェースがまず指示を受け取り、内容を解釈してプリンターに対して指示を与えることで、はじめて印刷が実行されるわけです。</p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>Word とドライバ、そしてプリンターという三者の関係性が、3D API で GPU を操作する場合にも同じように存在しています。</p>
	<p>CPU 側にある JavaScript や C++ の実装や Unity などが、GPU と連携するためのインタフェースとなるのが OpenGL や WebGL であり、最終的に描画処理を行いスクリーンに出力するのが GPU の仕事になります。</p>
	<p><span class="capt">次のページの図を見ながらイメージできるようにしておきましょう</span></p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/012.jpg" alt=""></p>
	<p><span class="capt">CPU が別のハードウェアを操作するためのインタフェースとしての API やドライバ</span></p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>さて、それでは実際に、JavaScript 側ではどのような処理を行う必要があるのか、最初なので順番に処理を追いかけていってみましょう。</p>
	<p>これらはけして「暗記する必要は無い」ので、まずは流れをざっくりとで構いませんから把握しておきましょう。</p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>WebGL では、canvas エレメントから取得した <code>WebGLRenderingContext</code> と呼ばれるコンテキストを経由して様々な処理を行います。スクールのサンプルでは <code>gl</code> という変数がこの WebGL のコンテキストを格納するための変数として統一されています。</p>
	<p>ですから、コードのなかに <code>gl.xxxxx</code> というように <code>gl.</code> から始まる記述があったときは、それが <em>WebGL の API をコールしているもの</em> なのだな、と考えるといいでしょう。</p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<pre><code class="javascript"><span class="comment">// webgl コンテキストを初期化</span>
gl = canvas.getContext(<span class="string">'webgl'</span>);</code></pre>
	<p><span class="capt">ここで登場する <code>gl</code> という変数に、WebGL の API を利用するための WebGL コンテキストが格納される</span></p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>そして WebGL や OpenGL では、シェーダを利用するために「GLSL で書かれたシェーダのソースコード」を取得してシェーダを初期化していきます。</p>
	<p>シェーダとは一種の小さなプログラムなので、GLSL のソースコード（これは単なる文字列）を JavaScript 側でコンパイルするという手順が必要になります。</p>
	<p>コンパイルされたシェーダは、単なる文字列の羅列から、そこで初めて実態のあるシェーダオブジェクトになります。</p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/013.jpg" alt=""></p>
	<p><span class="capt">ファイル由来でなくても、単に変数に文字列を直接代入したものなどでもよい</span></p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>さて、シェーダオブジェクトがコンパイルされて生成されても、実はこれでゴールではありません。</p>
	<p>シェーダには、最初のほうで解説したとおり頂点シェーダとフラグメントシェーダという、種類の異なるものが複数存在しますよね。</p>
	<p>これらの種類が異なるシェーダは、それぞれにデータの受け渡しなどを行う場合があるため、これらを管制する役割のものが必要です。</p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>シェーダ同士、あるいはシェーダと CPU とを結ぶ役割を持つ、管制塔のようなオブジェクトが GL には用意されています。</p>
	<p>これを <em>プログラムオブジェクト</em> と呼び、コンパイル済みのシェーダオブジェクトを、このプログラムオブジェクトに関連付ける（リンクする）ことにより、やっとシェーダを使った描画を行うための準備が完了します。</p>
	<p><span class="capt">言葉だけではイメージが難しいと思うので図を見て考えよう</span></p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p><img src="GLSL%20%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B%E3%82%92%E7%9F%A5%E3%82%8D%E3%81%86_files/014.jpg" alt=""></p>
	<p><span class="capt">シェーダそのものというよりプログラムオブジェクトが GPU とやりとりする</span></p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れ</h4>
	<p>先ほどプリンタのドライバの例を出しましたが、プログラムオブジェクトはまさにプランタのドライバのような存在です。</p>
	<p>印刷したいデータをプリンタに送るのがドライバの役割であるのと同じように、GPU 側にある GLSL（シェーダ）に対してデータを送り込むことができるのがプログラムオブジェクトです。</p>
	<p>プログラムオブジェクトはその他にも、GLSL 側で利用されている変数の情報を取得したりするのにも活躍する頼れる存在だと考えるといいでしょう。</p>
</div>
<div class="page">
	<h4>WebGL の初期化の流れまとめ</h4>
	<ul>
		<li>API 名などを暗記する必要はないが大きな流れをまずは掴むことが大切</li>
		<li>シェーダのソースコードは、要するに単なる文字列なので……</li>
		<li>それをアプリケーション側にある WebGL の API でコンパイルする</li>
		<li>コンパイルしたシェーダはプログラムオブジェクトに関連付けする</li>
		<li>プログラムオブジェクトが GPU と情報のやりとりを行ってくれる</li>
	</ul>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>WebGL の描画までの流れ</h4>
	<p>さて、プログラムオブジェクトが無事にシェーダのリンクまでを行ったら、次は、GLSL のソースコードに記述されている変数の情報をアプリケーション側（JavaScript 側）で捕捉してやらなくてはいけません。</p>
	<p>GLSL 側でどんな名前の変数を使っているのか、その変数のデータ型はなんのか……</p>
	<p>そういったことをしっかり確認しながら、双方で正しいやりとりが行えるよう準備をしていきます。</p>
</div>
<div class="page">
	<h4>WebGL の描画までの流れ</h4>
	<p>C 言語などのプログラミングでは「ポインタ」というのが頻繁に登場しますが、GLSL の場合はこれが <em>ロケーション</em> と呼ばれるものに相当します。</p>
	<p>意味としてはほとんどそのままの意味で捉えればよくて、要は「対象の変数が（GPU 内の）広大なメモリ畑の中の、どのロケーションを指し示しているか」ということを取得して使うわけですね。</p>
	<p><span class="capt">CPU と GPU は物理的に離れているのでこういう処理が必要なんですね</span></p>
</div>
<div class="page">
	<h4>WebGL の描画までの流れ</h4>
	<p>ロケーションの取得には、前述のプログラムオブジェクトが活躍します。</p>
	<p>プログラムオブジェクトに正しくシェーダがアタッチされている状態で、プログラムオブジェクトに対して「この名前の変数のロケーションはどうなってるの？」というふうに尋ねてやれば、該当する変数のロケーション情報を得ることができます。</p>
	<p><span class="capt">CPU 側と GPU 側の通訳みたいな感じですね</span></p>
</div>
<div class="page">
	<h4>WebGL の描画までの流れ</h4>
	<pre><code class="javascript"><span class="comment">// プログラムオブジェクトから attribute location を取得しストライドを設定する</span>
scenePrg.attLocation[<span class="number">0</span>] = gl.getAttribLocation(scenePrg.program, <span class="string">'position'</span>);</code></pre>
	<p><span class="capt">該当するプログラムオブジェクトを介して、名前を指定することで変数のロケーションが取得できる</span></p>
</div>
<div class="page">
	<h4>WebGL の描画までの流れ</h4>
	<p>取得したロケーションは、あとあと GPU 側、つまりシェーダにデータを流し込む際に必要になります。</p>
	<p>要するに <em>GPU 側で動作する GLSL で定義された変数</em> に、何かしらのデータをロケーションをたよりに渡して利用する、ということがこれで行えるようになったわけです。</p>
	<p><span class="capt">CPU の世界と GPU の世界がつながった！</span></p>
</div>
<div class="page">
	<h4>WebGL の描画までの流れのまとめ</h4>
	<ul>
		<li>シェーダが動作するのは GPU の世界</li>
		<li>CPU 側にあるアプリケーションから GPU の世界に干渉するには……</li>
		<li>プログラムオブジェクトが橋渡し役になってくれる</li>
		<li>GPU 側（GLSL）の変数はロケーションを取得して捕捉する</li>
		<li>CPU からはロケーションを指定してデータを流し込む</li>
	</ul>
	<p><span class="capt">GPU 側に GLSL で書かれたシェーダプログラムがある、ということを意識しよう</span></p>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>GLSL の変数</h4>
	<p>座学が長くて覚えないといけないことも多いのでちょっと大変ですが、実際にシェーダで利用することになる GLSL の「変数」についても、簡単に確認しておきましょう。</p>
	<p>GLSL でも、JavaScript などと同様に基本的には開発者が自由に変数を定義できます。</p>
	<p>ただし、GLSL に独特な変数宣言のルール、というのがあるので、ここからはそれを見ていきます。</p>
</div>
<div class="page">
	<h4>GLSL の変数</h4>
	<p>GLSL では変数を宣言する際に、代表的なところでは以下のようなものを指定します。</p>
	<ul>
		<li>変数のデータ型</li>
		<li>変数の種類を表す修飾子</li>
	</ul>
	<p><span class="capt">JavaScript とは違い型定義はかなり厳密です</span></p>
</div>
<div class="page">
	<h4>GLSL の変数</h4>
	<ul>
		<li>変数のデータ型</li>

	</ul>	<p>変数のデータ型はもうそのままの意味です。</p>
	<p>浮動小数点なのか整数なのか、あるいはベクトル型なのか……といった具合に、いくつかのデータ型を指定できます。</p>
	<p>型を省略して暗黙の宣言を行ったりすることはできません。</p>
</div>
<div class="page">
	<h4>GLSL の変数</h4>
	<pre><code class="javascript">* <span class="literal">int</span>:       整数
* <span class="literal">float</span>:     浮動小数点
* <span class="literal">bool</span>:      真偽値
* vec系:     ベクトル（<span class="literal">vec2</span> ～ <span class="literal">vec4</span> があり中身は <span class="literal">float</span>）
* mat系:     行列（<span class="literal">mat2</span> ～ <span class="literal">mat4</span> があり中身は <span class="literal">float</span>）
* sampler系: サンプラ（始めはテクスチャと読み替えても良い）</code></pre>
	<p><span class="capt">データ型についてはサンプル 005 のなかでも詳しく説明しています</span></p>
</div>
<div class="page">
	<h4>GLSL の変数につくストレージ修飾子</h4>
	<ul>
		<li>変数の種類を表す修飾子</li>

	</ul>	<p>GLSL では変数の型とは別に、その変数の持つ意味合いを表現するための「修飾子」が用意されています。</p>
	<p>実は、この部分がシェーダを理解する上で <em>非常に重要</em> です。</p>
	<p>最初は大変だと思いますが、本当にこれがわからないとなにも始まらないというくらい大切なので、ここでしっかり把握しておきましょう。</p>
</div>
<div class="page">
	<h4>GLSL の変数につくストレージ修飾子</h4>
	<p><strong>attribute</strong></p>
	<p>attribute 修飾子は、アプリケーションから送られてきた <em>頂点の情報</em> が格納される変数に用いられます。</p>
	<p>頂点シェーダは、頂点ひとつひとつに対してそれぞれ実行されます。頂点が個別に持っている座標や色などの情報は、頂点シェーダ内では attribute 修飾子付きの変数を参照することで取得できるわけですね。</p>
	<p><span class="capt">attribute → 頂点の情報を持つ変数！</span></p>
</div>
<div class="page">
	<h4>GLSL の変数につくストレージ修飾子</h4>
	<p><strong>uniform</strong></p>
	<p>uniform 修飾子は、アプリケーション（javascript）から渡されるグローバル変数です。</p>
	<p>attribute 修飾子付きの変数は、個々の頂点が持つ固有の情報を持つものだったのに対し、uniform 変数はグローバル変数のように振る舞うため、常にアプリケーションから送られてきた情報が格納されており、どの頂点に対しても均一に作用します。</p>
	<p><span class="capt">uniform → 一種のグローバル変数！</span></p>
</div>
<div class="page">
	<h4>GLSL の変数につくストレージ修飾子</h4>
	<p><strong>varying</strong></p>
	<p>varying 修飾子付きの変数について考える際は、グラフィックスパイプラインの構造を思い出して考えてみましょう。</p>
	<p>グラフィックスパイプラインでは、必ず頂点シェーダが先にありました。その後、フラグメントシェーダへと値が受け渡され、ピクセル単位での処理が行われるのでしたね。このとき「値の受け渡し」に使われるのが、他ならぬ varying 変数です。</p>
	<p><span class="capt">varying → シェーダ間のやり取り用！</span></p>
</div>
<div class="page">
	<h4>GLSL のストレージ修飾子まとめ</h4>
	<ul>
		<li>attribute は、頂点それぞれが固有に持つ情報を格納</li>
		<li>uniform はアプリケーションから送られてくるグローバルな情報</li>
		<li>varying は頂点シェーダからフラグメントシェーダへの橋渡しをする</li>
	</ul>
	<p><span class="capt">それぞれの役割は非常に重要なのでしっかり覚えておきましょう</span></p>
</div>
<div class="page">
	<h4>ロケーション取得方法の基本</h4>
	<p>attribute 変数と uniform 変数の両者は、頂点に属するか、グローバルなのか、という点で意味が大きく異なります。</p>
	<p>ただし、いずれもアプリケーションからデータを受け取る、という点では共通しています。</p>
	<p>varying 変数はシェーダ同士のやりとりなので関係ありませんが、前者は JavaScript や C++ で記述されたアプリケーションからなにかしらの入力を受け取って、シェーダ内で利用するためのものなのですね。</p>
</div>
<div class="page">
	<h4>ロケーション取得方法の基本</h4>
	<p>これらふたつの修飾子を持つ変数は、先ほど少し出てきた <em>変数のロケーション</em> を、<em>変数名を元にして</em> 取得します。</p>
	<p>大文字小文字はもちろん区別しつつ、変数名とまったく同じ文字列をプログラムオブジェクト経由で検索してやることで、ロケーションを取得することができます。</p>
</div>
<div class="page">
	<h4>ロケーション取得方法の基本</h4>
	<p>描画を実際に行う段階までの間に、シェーダに対して事前にデータを送ってやらなくてはなりません。つまり、描画を開始する前の初期化処理のなかでロケーション情報をあらかじめ取得しておく必要があります。</p>
	<p>取得したロケーションをどのように使うのかは、attribute 変数と uniform 変数で若干手順が異なるので紛らわしいのですが……</p>
	<p>ロケーションを取得する処理そのものは、最初にまとめて一気に行ってしまうのがわかりやすくていいでしょう。</p>
	<p><span class="capt">最初はすごく手間に感じるかもしれませんが地味に大事なロケーション取得処理</span></p>
</div>
<div class="page">
	<h4>ロケーション取得から描画まで</h4>
	<p>さて、非常に説明することが多かったですが、ロケーションの取得まで行えたら、あとはもう適切にデータをシェーダに送り込んで、描画を行うだけです。</p>
	<p>取得したロケーションを窓口として、どのようにデータを送り込んでやったらいいのかは、実際にサンプルを見ながら考えたほうが、わかりやすいと思います。</p>
	<p>ここからはいよいよサンプルの中身をより詳しく見ていきますが、サンプルにはコメントがかなり細かく書いてあるので、スライドよりも、サンプルのコメントのほうを参照しながら流れを追いかけるようにしてみましょう。</p>
	<p><span class="capt">最初なのでサンプル 001 だけは特に念入りに、細かく見ていきます</span></p>
</div>
<div class="page">
	<h4>サンプル 001（再）</h4>
	<p><strong>頂点の情報を定義している箇所を探してみよう</strong></p>
	<p>JavaScript 側の <code>init</code> 関数の冒頭あたりに、頂点を定義している箇所があります。</p>
	<p>頂点は単に配列として定義すればよく、<em>GLSL 側で vec3 で宣言された position</em> という attribute 変数に渡すデータなので、JavaScript 側でも <em>xyz でデータがワンセットになるように要素数を調整する</em> 必要があります。</p>
</div>
<div class="page">
	<h4>サンプル 001（再）</h4>
	<p><strong>背景をクリアする色の指定は 0.0 ～ 1.0 で指定</strong></p>
	<p>WebGL や GLSL では RGBA は全て 0.0 ～ 1.0 の範囲で表します。</p>
	<p>CSS や HTML では 16 進数を使って <code>#FFFFFF</code> のように表しますが、GLSL では <code>vec4(1.0, 1.0, 1.0, 1.0)</code> が完全に不透明な白に相当します。</p>
	<p>背景をクリアする色の指定を行っている <code>gl.clearColor</code> などでも、同様の値の範囲で色を指定します。</p>
</div>
<div class="page">
	<h4>サンプル 001（再）</h4>
	<p><strong>ビューポート（viewport）が描画される矩形の定義</strong></p>
	<p>WebGL や OpenGL では、描画する領域のことをビューポートと呼びます。</p>
	<p>ウィンドウサイズや、WebGL 等のレンダリング対象になっている canvas の大きさが変化するときには、ビューポートも再設定が必要になります。</p>
	<p>仮に、ビューポートを小さく設定して描画してみるとどんなことが起こるか、実際に試してみるといいでしょう。</p>
</div>
<div class="page">
	<h4>サンプル 001（再）</h4>
	<p><strong>どのプログラムオブジェクトを利用するかしっかり指定</strong></p>
	<p>おさらいになりますが、シェーダはコンパイルされた後でプログラムオブジェクトに紐付けされます。</p>
	<p>つまりアクティブなプログラムオブジェクトを別のプログラムオブジェクトに切り替えると、シェーダがそっくり入れ替わることになるわけです。</p>
	<p>これから使おうとしているプログラムオブジェクトがどれなのか、しっかり意識することを習慣づけましょう。</p>
</div>
<div class="page">
	<h4>サンプル 001（再）</h4>
	<p><strong>GPU にデータを送り、描画命令を発行する</strong></p>
	<p>WebGL や OpenGL では、描画を実際に行うのは GPU の仕事です。</p>
	<p>ですから「描画を行うために必要なデータ」は、事前に GPU に全て渡し終えておかなくてはいけません。</p>
	<p>描画命令（<code>gl.drawArrays</code> など）が発行されたとき、その時点で GPU に転送済みだったデータが描画に使われるのですね。</p>
</div>
<div class="page">
	<h4>サンプル 001（再）</h4>
	<p><strong>GLSL 側で gl_ の接頭語が付いているものはビルトイン変数</strong></p>
	<p>ビルトイン変数とは定義しなくてもそのまま利用できる変数のことです。</p>
	<p><code>gl_</code> の接頭語がついている変数は、あらかじめ GLSL の仕様で定義されているビルトイン変数で、それぞれ役割が明確に決められています。<code>gl_Position</code> であれば、これは頂点座標を格納するためのものですし、<code>gl_FragColor</code> であれば、これは最終的に画面に出力される色の情報になります。</p>
</div>
<div class="page">
	<h4>サンプル 001（再）</h4>
	<p>しつこいようですが……</p>
	<p>この講義の時間内で、全てのことを同時に覚えるのは無理があります。まずは、全体の流れや、自分の理解しやすいポイントになるところをしっかりと押さえておき、少しずつ時間を掛けて理解を深めていきましょう。</p>
	<p>ここから他のサンプルも一気に解説していきますが、最初はわからなくても落ち込む必要はありません。ちょっとずつ、自分のペースで理解していけば
問題ありませんし、そのために Slack などを用意して質問も受け付けられるようにしているので、とにかく気負いしすぎないことが大切です！</p>
	<p><span class="capt">ラクな気持ちで楽しく取り組むのが一番！</span></p>
</div>
<div class="page">
	<h4>サンプル 002</h4>
	<ul>
		<li>ブラウザの世界ではマウスカーソルの座標は「スクリーン座標系」</li>
		<li>GLSL の世界は -1.0 ～ 1.0 の範囲に限定された世界（正規化デバイス座標系）になっている</li>
		<li>ふたつの世界で座標の扱いが異なる状態であることに注意</li>
		<li>ここでは座標系の違いを変換することで揃える作業を行っている</li>
		<li>vec 系の変数は一種の配列のようなものと考えてみる</li>
		<li>uniform 変数は頂点に依存しないグローバルな変数</li>
	</ul>
	<p><span class="capt">uniform と attribute の違いをしっかり意識しよう</span></p>
</div>
<div class="page">
	<h4>サンプル 003</h4>
	<ul>
		<li>頂点属性、すなわち attribute 変数を追加し、頂点に色を持たせる</li>
		<li>attribute 変数を追加するときの手順（変更箇所）を意識する</li>
		<li>頂点の持つ色を、最終的に画面に出力できるのはフラグメントシェーダなので……</li>
		<li>色に関する処理はフラグメントシェーダに varying 修飾子つき変数で渡す</li>
		<li>頂点シェーダは、頂点の座標を変換するなど、頂点に属する処理を行うのが主な役割</li>
	</ul>
	<p><span class="capt">シェーダごとの役割の違いをしっかり意識しよう</span></p>
</div>
<div class="page">
	<h4>サンプル 004</h4>
	<ul>
		<li>インデックスを用いて描画する方法では、頂点を再利用できる</li>
		<li>つまりインデックスで指定できれば重複定義を減らすことができる</li>
		<li>プリミティブタイプの指定は描画命令と同時に行っている</li>
		<li>独自に頂点やインデックスを定義できればどのような形状も表現できる</li>
	</ul>
	<p><span class="capt">自分の思い描いた幾何学形状（たとえば星型など）を描画してみよう</span></p>
</div>
<div class="page">
	<h4>サンプル 005</h4>
	<p>※サンプル 005 はシェーダの基本概念をコメントに大量に記載してあります。</p>
	<ul>
		<li>GLSL でよく利用される様々な概念を押さえよう</li>
		<li>一度に暗記するのではなく、少しずつ自分なりにシェーダに取り入れていこう</li>
		<li>GLSL では特に間違いやすいところとしてデータ型の厳密さに注意すること</li>
		<li>シェーダだけで頂点を制御したり、色を制御したりできることをイメージできるように</li>
	</ul>
</div>
<div class="page">
	<h4>サンプル 006</h4>
	<ul>
		<li>ベクトルの概念を思い出しながら考える</li>
		<li><code>length</code> ではベクトルの長さを測ることができる</li>
		<li>GLSL の空間は <code>-1.0 ~ 1.0</code> の範囲を持つことを意識する</li>
		<li>このサンプルは実用性は無いが、ベクトルの長さをイメージできるようにしておいて損は無し！</li>
		<li>わかりにくければ描画するプリミティブタイプを <code>gl.POINTS</code> などにしてみてもよい</li>
	</ul>
</div>
<div class="page">
	<h4>サンプル 007</h4>
	<ul>
		<li>ここはちょっと変則的なサンプルの例</li>
		<li>頂点が <code>0.0 ～ 1.0</code> の単体の頂点属性しか持っていない状態</li>
		<li>つまり XYZ の座標をあらかじめ持っているわけではない</li>
		<li>シェーダ側だけで、全ての頂点の位置を決定している</li>
		<li>サインとコサイン、カーソルの位置を使って頂点の位置を動かしている</li>
	</ul>
	<p><span class="capt">こういうこともできる、という一例です</span></p>
</div>
<div class="page">
	<h4>サンプル 008</h4>
	<ul>
		<li>サンプル 007 をさらに改造</li>
		<li>動きのロジックは同じだが、色にも反映させている</li>
		<li>GLSL では <code>console.log</code> のような値を数値で見る方法が無い</li>
		<li>そのかわり、こうして色で出力することで値を予測できる</li>
		<li>値の大小や、正負は、正規化して色にすれば可視化できる</li>
	</ul>
	<p><span class="capt">シェーダでは色デバッグに慣れておくと幸せになれます！</span></p>
</div>
<div class="page">
	<h4>サンプル 009</h4>
	<ul>
		<li>X 座標の位置は一度設定したら変えないようにし、横一列に並べる</li>
		<li>Y 座標の位置は、マウスカーソルの位置とサインの値を使って決める</li>
		<li>サインの性質をよく思い出しながら考えること</li>
		<li>周期、高さなど、カーソルの位置から影響を受ける</li>
	</ul>
</div>
<div class="page">
	<h4>サンプル 010</h4>
	<ul>
		<li>サンプル 009 までとは違い頂点属性が vec2 になっているのがポイント</li>
		<li>ひとつ目の要素には、サンプル 009 まで同様に <code>0.0 ~ 1.0</code> の値</li>
		<li>ふたつ目の要素には、交互に正負の値が入るようになっている</li>
		<li>シェーダ内では、ふたつ目の要素を見て Y 方向の移動を制御している</li>
		<li>JavaScript 側でどのように描画命令を発行しているのかにも注目！</li>
	</ul>
</div>
<div class="page">
	<h4>サンプル 011</h4>
	<ul>
		<li>時間の経過をシェーダに送りアニメーションさせる</li>
		<li>このとき「時間の経過は頂点それぞれではなく全体に共通の値」であることを意識する</li>
		<li>つまり attribute ではなく uniform としてシェーダに送る</li>
		<li>時間の経過をどのように利用するかによって見た目も大きく変わる</li>
	</ul>
</div>
<div class="page">
	<h4></h4>
</div>
<div class="page">
	<h4>次回へ向けて</h4>
	<p>さて、初回からなかなか覚えることが多くハードな内容だったかと思いますが、いかがでしたでしょうか。</p>
	<p>シェーダという概念は、まずその存在としての意味の理解、そしてその構文などの知識の理解と、一度に覚えなければならないことが非常に多いです。どのようなプログラミングの世界でも同じだと思いますが、最初は、これらのことを地道に少しずつ理解していくしかありません。</p>
</div>
<div class="page">
	<h4>次回へ向けて</h4>
	<p>大切なことは <em>どんどん動かしてみる</em> ことです。</p>
	<p>自分で修正した結果が、どのような形で描画結果へ反映していくのかをよく観察し、その結果を見ながらさらに考察を重ねていく。これが大切です。</p>
	<p>シェーダを利用するようなグラフィックスプログラミングでは、まず絵が出るというところまでたどり着くことが非常に大変です。サンプルを活用すれば、一番の難所である「まず絵が出た状態」には最初から至っている状態ですので、あとはひたすらチャレンジしていくだけです。</p>
</div>
<div class="page">
	<h4>次回へ向けて</h4>
	<p>GLSL の場合に限らないと思いますが、プログラミングは自分で考えてコードを書き、どんどん実際に動かしてみることでスキルが身についていきます。</p>
	<p>まずは GLSL に慣れるためにも、今回の基礎の内容をしっかり身につけておきましょう。変数の型や、いくつかの用語の意味など、それらを事前に理解しているかどうかは今後の習熟度に大きく影響してきます。</p>
	<p>最初はきついと思いますが、シェーダコーディングでもやっぱり最初が肝心です。一緒にがんばりましょう！</p>
</div>
<div class="page">
	<h4>おまけ</h4>
	<p>本講義のスライドには、スライドの最後に理解度テストを添付します。</p>
	<p>こちらは自身の理解度を測る指針として、よかったら活用してみてください。</p>
</div>
<div class="page">
	<h4>question 1</h4>
	<p>このスクールで利用する GLSL のバージョンは……</p>
	<p><input id="radio01_01" name="radio01" type="radio"><label for="radio01_01">GLSL 1.x</label></p>
	<p><input id="radio01_02" name="radio01" type="radio"><label for="radio01_02">GLSL 2.x</label></p>
	<p><input id="radio01_03" name="radio01" type="radio"><label for="radio01_03">GLSL ES 1.x</label></p>
	<p><input id="radio01_04" name="radio01" type="radio"><label for="radio01_04">GLSL ES 2.0</label></p>
</div>
<div class="page">
	<h4>question 2</h4>
	<p>次のうち WebGL + GLSL の組み合わせで記述できるシェーダは頂点シェーダと何？</p>
	<p><input id="radio02_01" name="radio02" type="radio"><label for="radio02_01">フラグメントシェーダ</label></p>
	<p><input id="radio02_02" name="radio02" type="radio"><label for="radio02_02">ジオメトリシェーダ</label></p>
	<p><input id="radio02_03" name="radio02" type="radio"><label for="radio02_03">テッセレーションシェーダ</label></p>
	<p><input id="radio02_04" name="radio02" type="radio"><label for="radio02_04">コンピュートシェーダ</label></p>
</div>
<div class="page">
	<h4>question 3</h4>
	<p>頂点シェーダが実行される回数は何と等しくなる？</p>
	<p><input id="radio03_01" name="radio03" type="radio"><label for="radio03_01">頂点の数</label></p>
	<p><input id="radio03_02" name="radio03" type="radio"><label for="radio03_02">ポリゴンの数</label></p>
	<p><input id="radio03_03" name="radio03" type="radio"><label for="radio03_03">ラインの数</label></p>
	<p><input id="radio03_04" name="radio03" type="radio"><label for="radio03_04">画素数</label></p>
</div>
<div class="page">
	<h4>question 4</h4>
	<p>フラグメントシェーダが実行される回数は何と等しくなる？</p>
	<p><input id="radio04_01" name="radio04" type="radio"><label for="radio04_01">頂点の数</label></p>
	<p><input id="radio04_02" name="radio04" type="radio"><label for="radio04_02">ポリゴンの数</label></p>
	<p><input id="radio04_03" name="radio04" type="radio"><label for="radio04_03">画面全体の画素数</label></p>
	<p><input id="radio04_04" name="radio04" type="radio"><label for="radio04_04">頂点やポリゴンを描画する部分の画素数</label></p>
</div>
<div class="page">
	<h4>question 5</h4>
	<p>WebGL + GLSL の頂点シェーダに「必須ではない」ものはどれ？</p>
	<p><input id="radio05_01" name="radio05" type="radio"><label for="radio05_01">main 関数</label></p>
	<p><input id="radio05_02" name="radio05" type="radio"><label for="radio05_02">attribute 変数</label></p>
	<p><input id="radio05_03" name="radio05" type="radio"><label for="radio05_03">uniform 変数</label></p>
	<p><input id="radio05_04" name="radio05" type="radio"><label for="radio05_04">gl_Position</label></p>
</div>
<div class="page">
	<h4>question 6</h4>
	<p>attribute 変数の説明として間違っているのはどれ？</p>
	<p><input id="radio06_01" name="radio06" type="radio"><label for="radio06_01">VBO と呼ばれるバッファの情報を受け取る</label></p>
	<p><input id="radio06_02" name="radio06" type="radio"><label for="radio06_02">頂点ごとにユニークな情報を受け取る</label></p>
	<p><input id="radio06_03" name="radio06" type="radio"><label for="radio06_03">ベクトルだけでなく float も受け取れる</label></p>
	<p><input id="radio06_04" name="radio06" type="radio"><label for="radio06_04">フラグメントシェーダに記述することもできる</label></p>
</div>
<div class="page">
	<h4>question 7</h4>
	<p>uniform 変数の説明として間違っているのはどれ？</p>
	<p><input id="radio07_01" name="radio07" type="radio"><label for="radio07_01">頂点シェーダで使える</label></p>
	<p><input id="radio07_02" name="radio07" type="radio"><label for="radio07_02">フラグメントシェーダで使える</label></p>
	<p><input id="radio07_03" name="radio07" type="radio"><label for="radio07_03">行列の情報を送信するためだけに使う</label></p>
	<p><input id="radio07_04" name="radio07" type="radio"><label for="radio07_04">その時描かれる全ての頂点が同じ情報を使う</label></p>
</div>
<div class="page">
	<h4>question 8</h4>
	<p>次のうち、GLSL として正しい書き方はどれ？</p>
	<p><input id="radio08_01" name="radio08" type="radio"><label for="radio08_01">int i = 1;</label></p>
	<p><input id="radio08_02" name="radio08" type="radio"><label for="radio08_02">int i = 1.0;</label></p>
	<p><input id="radio08_03" name="radio08" type="radio"><label for="radio08_03">int i = 1i;</label></p>
	<p><input id="radio08_04" name="radio08" type="radio"><label for="radio08_04">int i = (int)1.0;</label></p>
</div>
<div class="page">
	<h4>question 9</h4>
	<p>次のうち、GLSL として正しくない書き方はどれ？</p>
	<p><input id="radio09_01" name="radio09" type="radio"><label for="radio09_01">float f = vec3(1.0);</label></p>
	<p><input id="radio09_02" name="radio09" type="radio"><label for="radio09_02">float f = vec3(1.0).x;</label></p>
	<p><input id="radio09_03" name="radio09" type="radio"><label for="radio09_03">vec3 v = vec3(1.0);</label></p>
	<p><input id="radio09_04" name="radio09" type="radio"><label for="radio09_04">vec3 v = vec3(1.0).xxx;</label></p>
</div>
<div class="page">
	<h4>question 10</h4>
	<p><code>length</code> 関数にベクトルを与えたときの戻り値は？</p>
	<p><input id="radio10_01" name="radio10" type="radio"><label for="radio10_01">同じ次元のベクトル</label></p>
	<p><input id="radio10_02" name="radio10" type="radio"><label for="radio10_02">浮動小数点（float）</label></p>
	<p><input id="radio10_03" name="radio10" type="radio"><label for="radio10_03">一次元減らしたベクトル</label></p>
	<p><input id="radio10_04" name="radio10" type="radio"><label for="radio10_04">引数の中身によって変わる</label></p>
</div>
<div class="page">
	<h4>結果はいかに！？</h4>
	<p></p><div id="ansButton">答え合わせ</div><p></p>
	<p>結果が振るわなかったとしても、落ち込む必要はありません。</p>
	<p>ブラウザのコンソールに、どこの問題が間違えていたのかなどが表示されていますので、間違えた部分を重点的に復習しておきましょう。</p>
</div>
<div class="page">
</div>

        </div>
        <div id="footer">
            <div id="prev">◁</div>
            <div id="navi">
                <div id="count">1</div>
                <div id="separator">|</div>
                <div id="total">147</div>
            </div>
            <div id="next">▷</div>
        </div>
    </div>
    <div id="layer">
        <div id="menu">
            <!-- <div class="line">                     -->
            <!--     <div>test string test strubg</div> -->
            <!--     <div class="arrow">▷</div>       -->
            <!-- </div>                                 -->
        <div class="line"><div>home</div><div class="arrow">▷</div></div><div class="line"><div>自己紹介</div><div class="arrow">▷</div></div><div class="line"><div>本スクールの開催概要</div><div class="arrow">▷</div></div><div class="line"><div>講義を始める前に</div><div class="arrow">▷</div></div><div class="line"><div>さあはじめよう！</div><div class="arrow">▷</div></div><div class="line"><div>進化するシェーダ</div><div class="arrow">▷</div></div><div class="line"><div>ここまでの要点</div><div class="arrow">▷</div></div><div class="line"><div>3D API とシェーダ</div><div class="arrow">▷</div></div><div class="line"><div>OpenGL と OpenGL ES</div><div class="arrow">▷</div></div><div class="line"><div>OpenGL ES と WebGL</div><div class="arrow">▷</div></div><div class="line"><div>GLSL</div><div class="arrow">▷</div></div><div class="line"><div>ここまでの要点</div><div class="arrow">▷</div></div><div class="line"><div>固定機能パイプラインとプログラマブルシェーダ</div><div class="arrow">▷</div></div><div class="line"><div>すべて自分でやらなくてはならないプログラマブルシェーダ</div><div class="arrow">▷</div></div><div class="line"><div>シェーダの種類</div><div class="arrow">▷</div></div><div class="line"><div>頂点シェーダ</div><div class="arrow">▷</div></div><div class="line"><div>フラグメントシェーダ</div><div class="arrow">▷</div></div><div class="line"><div>WebGL で利用できるシェーダ</div><div class="arrow">▷</div></div><div class="line"><div>その他のシェーダ</div><div class="arrow">▷</div></div><div class="line"><div>ここまでの要点</div><div class="arrow">▷</div></div><div class="line"><div>グラフィックスパイプライン</div><div class="arrow">▷</div></div><div class="line"><div>ここまでの要点</div><div class="arrow">▷</div></div><div class="line"><div>サンプルを見ながら考えていこう</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 001</div><div class="arrow">▷</div></div><div class="line"><div>WebGL の初期化の流れ</div><div class="arrow">▷</div></div><div class="line"><div>WebGL の初期化の流れまとめ</div><div class="arrow">▷</div></div><div class="line"><div>WebGL の描画までの流れ</div><div class="arrow">▷</div></div><div class="line"><div>WebGL の描画までの流れのまとめ</div><div class="arrow">▷</div></div><div class="line"><div>GLSL の変数</div><div class="arrow">▷</div></div><div class="line"><div>GLSL の変数につくストレージ修飾子</div><div class="arrow">▷</div></div><div class="line"><div>GLSL のストレージ修飾子まとめ</div><div class="arrow">▷</div></div><div class="line"><div>ロケーション取得方法の基本</div><div class="arrow">▷</div></div><div class="line"><div>ロケーション取得から描画まで</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 001（再）</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 002</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 003</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 004</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 005</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 006</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 007</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 008</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 009</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 010</div><div class="arrow">▷</div></div><div class="line"><div>サンプル 011</div><div class="arrow">▷</div></div><div class="line"><div>次回へ向けて</div><div class="arrow">▷</div></div><div class="line"><div>おまけ</div><div class="arrow">▷</div></div><div class="line"><div>question 1</div><div class="arrow">▷</div></div><div class="line"><div>question 2</div><div class="arrow">▷</div></div><div class="line"><div>question 3</div><div class="arrow">▷</div></div><div class="line"><div>question 4</div><div class="arrow">▷</div></div><div class="line"><div>question 5</div><div class="arrow">▷</div></div><div class="line"><div>question 6</div><div class="arrow">▷</div></div><div class="line"><div>question 7</div><div class="arrow">▷</div></div><div class="line"><div>question 8</div><div class="arrow">▷</div></div><div class="line"><div>question 9</div><div class="arrow">▷</div></div><div class="line"><div>question 10</div><div class="arrow">▷</div></div><div class="line"><div>結果はいかに！？</div><div class="arrow">▷</div></div></div>
    </div>



</body></html>